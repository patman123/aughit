a=arduino('COM4') ;
a.servoAttach(9) ;
a.pinMode(2,'output');
a.pinMode(3,'output');
readerobj = VideoReader('e.avi', 'tag', 'arena');  %reading video from folder
lastframe=read(readerobj, get(readerobj,'NumberOfFrames') );
secondlast=read(readerobj,get(readerobj,'NumberOfFrames')-5) ;
firstframe=read(readerobj,1);

radius=16 ;width=10;                                                      % to get the middle two values of x coordintes which will be used in reflection later
leftb=10 ;
rightb=790;                                                    % taking x coordinated of left boundary and right boundary 
yspan=40;xspan=66;
lengthofarena=800 ;effL=lengthofarena-2*(radius+width);
ratio=3.35;             % ratio is the ratio of actual to virtual distance
ratio2=3.35;

paddleT=imread('paddleT.png');                                 % templates
ballT=imread('ballT.png');
b=imread('brickT.png');

cc=normxcorr2(paddleT(:,:,1),lastframe(:,:,1));                % paddle detection
[m,location]=max(abs(cc(:)));
[y,x]=ind2sub(size(cc),location);
paddletop=y-36;
paddlecenter=x-68; 


cc1=normxcorr2(ballT(:,:,2),lastframe(:,:,2));                 % ball detection 
cc2=normxcorr2(ballT(:,:,2),secondlast(:,:,2));
[m1,location1]=max(abs(cc1(:)));
[y1,x1]=ind2sub(size(cc1),location1);
[m2,location2]=max(abs(cc2(:)));
[y2,x2]=ind2sub(size(cc2),location2);
c1x=x1-19;c1y=y1-18;
c2x=x2-19;c2y=y2-18;


b_direction=(y2-y1)/(x2-x1);                                   % ball direction
 
if b_direction>0

	finaly=paddletop-radius;
	finalx=(finaly-c1y)/b_direction+ c1x- (radius+width);
	n=finalx/effL;n=floor(n);
	R=rem(finalx,effL);
	coll=rem(n,2);
	
	if(coll==0)
		new_pos=(radius+width)+R;
	else
		new_pos=lengthofarena-(radius+width)-R;
	end
			
end

if b_direction<0                                               % paddle movement

	b_direction=abs(b_direction);
	c1x=lengthofarena-c1x;
	finaly=paddletop-radius;
	finalx=(finaly-c1y)/b_direction+ c1x- (radius+width);
	n=finalx/effL;n=floor(n);
	R=rem(finalx,effL);
	coll=rem(n,2);
	
	if(coll==0)
		new_pos=lengthofarena-(radius+width)-R;
		
	else
		new_pos=(radius+width)+R;
	end
	b_direction = -(b_direction);
end 



                                       %% brick detection starts

diff_im = imsubtract(b(:,:,3), rgb2gray(b));
    diff_im=medfilt2(diff_im,[3 3]);
    diff_im=im2bw(diff_im,0.1);
    diff_im=bwareaopen(diff_im,50);                            
    bw5=bwlabel(diff_im,8);
	
	
	
    bound=lastframe ;                        
    diff_im = imsubtract(bound(:,:,1), rgb2gray(bound));
    diff_im=medfilt2(diff_im,[3 3]);
    diff_im=im2bw(diff_im,0.1);
    diff_im=bwareaopen(diff_im,50);                            
    bw1=bwlabel(diff_im,8);
                                 
    diff_im = imsubtract(bound(:,:,2), rgb2gray(bound));
    diff_im=medfilt2(diff_im,[3 3]);
    diff_im=im2bw(diff_im,0.1);
    diff_im=bwareaopen(diff_im,50);                            
    bw2=bwlabel(diff_im,8);
                                   
    diff_im = imsubtract(bound(:,:,3), rgb2gray(bound));
    diff_im=medfilt2(diff_im,[3 3]);
    diff_im=im2bw(diff_im,0.1);
    diff_im=bwareaopen(diff_im,50);                            
    bw3=bwlabel(diff_im,8);



bw4=bw1+bw2+bw3;        %bw4 is the image containg all elements in the image in white form
cc5=normxcorr2(bw5(:,:,1),bw4(:,:,1));
I=find(cc5 > 0.999 ) ;
[yb,xb]=ind2sub(size(cc5),I);
yb=yb-10-yspan/2;xb=xb-13-xspan/2;                               %%brick detection ends


                      %% brick aiming starts 

    xbs=sort(xb);
	ybs=sort(yb);
	paddlex=new_pos;
	paddley=paddletop;
    if b_direction>0            %%ball coming from left
		if coll==0                        %target left top brick
			
		targetbx=xbs(1);                   % left
		targetby=ybs(1);
		aim_angle=atan(( paddley-targetby-radius) /(paddlex-targetbx)) ;
		rotation=(aim_angle+atan(b_direction))/2;
		else                               % right
		
		sx=size(xbs);sizex=sx(1)*sx(2);targetbx=xbs(sizex);
		sy=size(ybs);sizey=sy(1)*sy(2);targetby=ybs(sizey);
		
		aim_angle=atan(abs( (paddley-targetby-radius) /(paddlex-targetbx-radius))) ;
		rotation=3.14-(aim_angle+atan(b_direction))/2; 
		end

	elseif b_direction<0                  %%ball coming from right 
                                   %%target right bottom brick
		b_direction=abs(b_direction);
		if coll==0                       % right
		  
		  sx=size(xbs);sizex=sx(1)*sx(2);targetbx=xbs(sizex);
		  sy=size(ybs);sizey=sy(1)*sy(2);targetby=ybs(sizey);
		  aim_angle=atan(abs( (paddley-targetby-radius) /(paddlex-targetbx-radius))) ;
		  rotation=3.14-(aim_angle+atan(b_direction))/2;
		else
				
		targetbx=xbs(1);               % left
		targetby=ybs(1);
		aim_angle=atan(( paddley-targetby-radius) /(paddlex-targetbx)) ;
		rotation=-(aim_angle+atan(b_direction))/2;
		end 
		b_direction = -b_direction;
     else
	 
	 end
				%% brick aiming ends here

					 


distance_moved=(new_pos-paddlecenter)/ratio;
distance_moved=round(distance_moved);
rotation=180*rotation/3.14;
rotation=round(rotation);
rotation=180-rotation;
if rotation >179 
rotation =90 ;
end
if rotation <1 
rotation =90 ;
end
%%a.servoWrite(9,rotation);


required_new_pos=0 ;



%% Initialization
redThresh = 0.13; % Threshold for red detection
vidDevice = imaq.VideoDevice('winvideo', 2, 'RGB24_800x600', ... % Acquire input video stream
                    'ROI', [1 1 800 600], ...
                    'ReturnedColorSpace', 'rgb');
vidInfo = imaqhwinfo(vidDevice); % Acquire input video property
hblob = vision.BlobAnalysis('AreaOutputPort', false, ... % Set blob analysis handling
                                'CentroidOutputPort', true, ... 
                                'BoundingBoxOutputPort', true', ...
                                'MinimumBlobArea', 800, ...
                                'MaximumBlobArea', 3000, ...
                                'MaximumCount', 10);
hshapeinsRedBox = vision.ShapeInserter('BorderColor', 'Custom', ... % Set Red box handling
                                        'CustomBorderColor', [1 0 0], ...
                                        'Fill', true, ...
                                        'FillColor', 'Custom', ...
                                        'CustomFillColor', [1 0 0], ...
                                        'Opacity', 0.4);
htextins = vision.TextInserter('Text', 'Number of Red Object: %2d', ... % Set text for number of blobs
                                    'Location',  [7 2], ...
                                    'Color', [1 0 0], ... // red color
                                    'FontSize', 12);
htextinsCent = vision.TextInserter('Text', '+      X:%4d, Y:%4d', ... % set text for centroid
                                    'LocationSource', 'Input port', ...
                                    'Color', [1 1 0], ... // yellow color
                                    'FontSize', 14);
hVideoIn = vision.VideoPlayer('Name', 'Final Video', ... % Output video player
                                'Position', [100 100 vidInfo.MaxWidth+20 vidInfo.MaxHeight+30]);
nFrame = 0; % Frame number initialization
y=1 ;centX=0;z=1 ;
%% Processing Loop
while(y&&nFrame<700)
    rgbFrame = step(vidDevice); % Acquire single frame
    %% rgbFrame = flipdim(rgbFrame,2); % obtain the mirror image for displaying
    diffFrame = imsubtract(rgbFrame(:,:,1), rgb2gray(rgbFrame)); % Get red component of the image
    diffFrame = medfilt2(diffFrame, [3 3]); % Filter out the noise by using median filter
    binFrame = im2bw(diffFrame, redThresh); % Convert the image into binary image with the red objects as white
    [centroid, bbox] = step(hblob, binFrame); % Get the centroids and bounding boxes of the blobs
    centroid = uint16(centroid); % Convert the centroids into Integer for further steps 
    rgbFrame(1:20,1:165,:) = 0; % put a black region on the output stream
    vidIn = step(hshapeinsRedBox, rgbFrame, bbox); % Instert the red box
    for object = 1:1:length(bbox(:,1)) % Write the corresponding centroids
        centX = centroid(object,1); centY = centroid(object,2);
        vidIn = step(htextinsCent, vidIn, [centX centY], [centX-6 centY-9]); 
    end
    vidIn = step(htextins, vidIn, uint8(length(bbox(:,1)))); % Count the number of blobs
    step(hVideoIn, vidIn); % Output video stream
    nFrame = nFrame+1;
 if centX ~=0
  if nFrame <50
    prev_pos=centX; z=0 ;
	required_new_pos=distance_moved*ratio2 + prev_pos ;
  end 
  if nFrame>50 &&z==0 
    if centX >round(required_new_pos) 
      a.digitalWrite(2,1);
      a.digitalWrite(3,0);
      end
    if centX <round(required_new_pos) 
      a.digitalWrite(2,0);
      a.digitalWrite(3,1);
      end
    if centX ==round(required_new_pos) 
        y= 0 ;
      a.digitalWrite(2,0);
      a.digitalWrite(3,0);
      end

   end  %% for nFrame>1 

end
end 
a.digitalWrite(2,0);
a.digitalWrite(3,0);
%% Clearing Memory
release(hVideoIn); % Release all memory and buffer used
release(vidDevice);
% clear all;
clc;
